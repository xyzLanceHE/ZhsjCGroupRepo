### 2021/8/29 （2）21：00

+ 确定了Pubisher改成非模板的可能性，Publisher现在完全无需模板，只需增加一个全局的模板函数做一下包装，用来生成Publisher即可。理论上，只要实现了委托类，Subscriber同样无需模板。
+ 检验模板参数并不需要std::is_base_of，因为用到了dynamic_cast，在编译阶段即可验证模板参数

### 2021/8/29 （2）16：30

本次提交：

+ 修复了类型信息跨平台不同的问题。
  + 现在改为使用自己的字符串进行SHA256散列，但也存在一些问题：
    + 计算过程理论上是静态的，甚至是编译阶段可以确定的，但目前却是每次获取的时候都计算一遍。后续可以考虑优化一下。
    + 无法区分模板的不同实例化。考虑过增加模板参数（const char*），但是会导致使用起来不够简洁。目前先靠应用层自己规避冲突好了，反正能用。
  + 改起来还挺简单的，改一下类型定义，再改一下Message里的相关实现就好了，Node和Master基本不用动
  + 为SHA256Value类型重载了等号和拷贝构造

+ 给openssl的SHA套了一层壳，单独作为一个编译单元，精简了头文件的内容

一些其他事项：

+ 感觉Publisher和Subscriber的类型设计有改进空间：
  + 这两个类目前都是模板，使用时将Message作为模板参数；但是同时Message类设计中，规定了一些纯虚方法，预期是使用者通过继承Message并实现虚方法来定义自己的消息类型。目前这两个类的代码，并没有充分利用Message本身的类型信息以及Message的动态特性，而是直接将一个类型带入模板，这个类型虽然也需要有那几个方法，但是并不要求派生自Message，也就损失了Message的设计意图。
  + 而且，模板类的声明和定义得放在一起，为了让声明与实现尽可能分离，目前做了许多中间工作，在模板类和实现类之间又铺了一个中间类型，关系绕来绕去的，有些混乱。
  + 因此，改进的方向是这两个类改成非模板类，仅定义一个模板构造方法，并在一开始就检验模板参数是否是Message的子类。（不过检验还是从编译阶段推迟到了运行阶段）。而后，类的内部便不再需要模板，而是依靠Message的多态实现各种操作。这样不仅充分利用了Message类，也可以之间将声明和实现分离而无需借助中间类。
  + 此外，Subscriber类的回调逻辑也有些混乱，在改进的同时改写一下回调逻辑。例如，依靠委托对象。
  + 以上这些有空就写，没有空就算了。



### 2021/8/29

TinyROS的所有模块已经基本完善了，今天编写了测试项目进行测试，

+ 发现了一些bug：

  + 申请已经存在的话题时应该返回该话题的port，而不是nextport（估计是复制粘贴忘改了）
  + Subscriber的构造函数忘了注册回调，并且有一个构造函数忘了调起初始化
  + Publisher的发布线程忘了detach

  这些都是小问题，改一下就好了。

+ Master暂时改为允许一个节点重复订阅一个话题。这是为了注册不同的回调函数。

  + 目前的Subscriber只能注册一个回调函数
  + 想要有多个回调函数，要么申请多个Subscriber，要么自己在回调函数里调用多个回调函数
  + 申请多个Subscriber显然是不合适的。后续考虑修改，例如封装一个类似于C#的多播委托类，Subscriber只需使用该类的一个对象构造，而使用者可以在后续的任何时间操作该对象，注册或者注销回调函数

+ 此外还有一个大问题：
  std::type_info的实现在不同平台的区别是不同的，只能保证平台内相同，但是不同平台得到的name和hash均不同，不能作为Message类型的判断标准。这导致了不同平台申请话题时会失败。因此，要把Message的类型ID改用自己的算法，初步考虑也改成SHA256.

+ 除此之外，测试暂未发现问题，在同一个平台内是可以通信的，并且Master和Node是可以跨平台通信的

+ 另外，实现了StringMessage类，可以传输字符串消息
